using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

public class CameraRailFollow : MonoBehaviour
{


    public List<Vector3> railPointPositions;

    //TODO: Establish Rail points in level, determine which way camera should move based on which rail point

    //curr, next, 

    public PlayerMovement player;
    public float boundsX = 200; //irrelevant rn gurrjjgjj


    //Bounds will be defined by the endpoints (linear search?)
    // Start is called before the first frame update
    void Awake()
    {
        player = GameObject.Find("GKnight").GetComponent<PlayerMovement>();
    }


    private void Start()
    {
        Vector3 a = new Vector3(-5, 0, 0);

        Vector3 c = new Vector3(0, 0, 0);

        Vector3 b = new Vector3(5, 0, 0);
        print(PointLiesOnSegment(a, b, c));
    }

    // Update is called once per frame
    void Update()
    {
        //current camera position is mapped to a line generated by the current two points
        //that the player is between, where x is the player position (for horizontal)

        //issue is that x linear mapping may not account for 'level progress'
        //also, checking between 2 x's is true for all points farther from the check point
        //X Y me Z W -> I am between Y and Z, but also between X and W by extension



        //first get the two points we are between.
        //
        Vector3 railPointA;
        Vector3 railPointB;

        if (Mathf.Abs(player.gameObject.transform.position.x) <= boundsX)
        {
            transform.position = new Vector3(player.transform.position.x, 4f, -10);
        }

    }

    private void OnDrawGizmos()
    {
        //Draw rail points
        for (int i = 0; i < railPointPositions.Count; i++) { 
            Gizmos.color = Color.cyan;
            Gizmos.DrawSphere(railPointPositions[i], .25f);
            if (i != railPointPositions.Count - 1) { //if at end, do not draw
                Gizmos.DrawLine(railPointPositions[i], railPointPositions[i + 1]);
            }
        }
        //great now we have a thing that represents the camera rail.
        //now lets put the camera on that rail, based on the player's position
        
    }

    bool PointLiesOnSegment(Vector3 start, Vector3 end, Vector3 mid) { 

         return mid.x <= end.x && mid.x >= start.x
            && mid.y <= end.y && mid.y >= start.y
            && mid.z <= end.z && mid.z >= start.z
            && Vector3.Cross(end - start, mid - start) == Vector3.zero;
    }



}
